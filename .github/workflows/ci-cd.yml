name: Simple CI/CD Pipeline

on:
  push:
    branches: [ staging ]

env:
  REGISTRY: asia-southeast1-docker.pkg.dev
  PROJECT_ID: verdant-bruin-464819-i9
  REPOSITORY: fastapi-todoapp
  IMAGE_NAME: fastapi-todoapp
  GKE_CLUSTER: todoapp-cluster
  GKE_ZONE: asia-southeast1-a

jobs:
  test:
    name: Test
    runs-on: ubuntu-latest
    
    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: test_password
          MYSQL_DATABASE: todoapp_test
        ports:
          - 3306:3306
        options: --health-cmd="mysqladmin ping" --health-interval=10s --health-timeout=5s --health-retries=3

    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.12'
    
    - name: Install dependencies
      run: |
        pip install -r requirements.txt
        pip install pytest pytest-asyncio httpx
    
    - name: Run tests
      env:
        DATABASE_URL: mysql+pymysql://root:test_password@127.0.0.1:3306/todoapp_test
      run: |
        # Create test database tables
        python -c "
        import models
        from database import engine
        models.Base.metadata.create_all(bind=engine)
        "
        # Run tests
        pytest tests/ -v

  build-and-deploy:
    name: Build & Deploy
    runs-on: ubuntu-latest
    needs: test
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
    
    - name: Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v2
    
    - name: Configure Docker for GCR
      run: gcloud auth configure-docker ${{ env.REGISTRY }}
    
    - name: Build Docker image
      run: |
        docker build -t ${{ env.REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/${{ env.IMAGE_NAME }}:staging-${{ github.sha }} .
        docker build -t ${{ env.REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/${{ env.IMAGE_NAME }}:staging-latest .
    
    - name: Push Docker image
      run: |
        docker push ${{ env.REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/${{ env.IMAGE_NAME }}:staging-${{ github.sha }}
        docker push ${{ env.REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/${{ env.IMAGE_NAME }}:staging-latest
    
    - name: Get GKE credentials
      run: |
        gcloud container clusters get-credentials ${{ env.GKE_CLUSTER }} --zone ${{ env.GKE_ZONE }}
    
    - name: Create staging namespace
      run: |
        kubectl create namespace staging --dry-run=client -o yaml | kubectl apply -f -
    
    - name: Deploy to staging
      run: |
        # Update the image in the deployment
        kubectl set image deployment/fastapi-deployment fastapi-todo=${{ env.REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/${{ env.IMAGE_NAME }}:staging-${{ github.sha }} -n staging
        
        # If deployment doesn't exist, create it
        if ! kubectl get deployment fastapi-deployment -n staging >/dev/null 2>&1; then
          # Create MySQL first
          kubectl apply -f k8s/mysql-deployment.yaml -n staging
          kubectl wait --for=condition=ready pod -l app=mysql -n staging --timeout=300s
          
          # Create FastAPI deployment
          kubectl apply -f k8s/fastapi-deployment.yaml -n staging
        fi
        
        # Wait for deployment to complete
        kubectl rollout status deployment/fastapi-deployment -n staging --timeout=300s
    
    - name: Run smoke tests
      run: |
        # Port forward to test the deployment
        kubectl port-forward service/fastapi-service 8080:80 -n staging &
        sleep 10
        
        # Test health endpoint
        curl -f http://localhost:8080/health || exit 1
        
        # Test main page
        curl -f http://localhost:8080/ || exit 1
        
        echo "‚úÖ Deployment successful!"
        echo "Staging environment updated with commit: ${{ github.sha }}"

  notify:
    name: Notify
    runs-on: ubuntu-latest
    needs: [test, build-and-deploy]
    if: always()
    
    steps:
    - name: Success notification
      if: needs.test.result == 'success' && needs.build-and-deploy.result == 'success'
      run: |
        echo "üéâ Deployment to staging successful!"
        echo "Commit: ${{ github.sha }}"
        echo "Branch: ${{ github.ref }}"
    
    - name: Failure notification
      if: needs.test.result == 'failure' || needs.build-and-deploy.result == 'failure'
      run: |
        echo "‚ùå Deployment failed!"
        echo "Tests: ${{ needs.test.result }}"
        echo "Build & Deploy: ${{ needs.build-and-deploy.result }}"
        exit 1
